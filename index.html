<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Camera to ASCII</title>
        <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: black; /* set the background color of the body to black */
      }
#ascii-art {
  font-family: monospace;
  white-space: pre;
  text-align: center;
  height: 100vh;
  background-color: black;
  color: transparent;
  background-image: linear-gradient(to bottom, #87CEFA, #4169E1);
  -webkit-background-clip: text;
  background-clip: text;
  /* fallback options for older browsers */
  color: #4169E1; /* set a solid blue color as a fallback */
  background-color: white; /* set a white background as a fallback */
}
          #ascii-container {
  border: 100px solid white;
  box-sizing: border-box;
  padding: 100px;
}
          #white-bar {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height:100px;
  background-color: white;
}
      #camera-button {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        font-size: 16px;
        background-color: #4169E1;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        outline: none;
      }
      #camera-button:hover {
        background-color: #87CEFA;
      }

    </style>
  </head>
  <body>
    <div id="ascii-container">
  <pre id="ascii-art"></pre>
</div>
    <video id="video" autoplay></video>
    <pre id="ascii-art"></pre>
<canvas id="white-bar"></canvas>
 <button id="camera-button">Toggle Camera</button>
    <script>
// Get the video element from the DOM
const video = document.createElement("video");
document.body.appendChild(video);

// Create a canvas element to draw the video frame on
const canvas = document.createElement("canvas");
const ctx = canvas.getContext("2d");

// Set the width and height of the canvas to match the video dimensions
video.addEventListener("loadedmetadata", () => {
  canvas.width = video.videoWidth * 3;
  canvas.height = video.videoHeight * (3/2);
});
      
const whiteBarCanvas = document.getElementById("white-bar");
const whiteBarCtx = whiteBarCanvas.getContext("2d");

function drawWhiteBar() {
  whiteBarCtx.fillStyle = "white";
  whiteBarCtx.fillRect(0, 0, whiteBarCanvas.width, whiteBarCanvas.height);
}

video.addEventListener("loadedmetadata", () => {
  // Set the width and height of the canvas and white bar elements to match the video dimensions
  canvas.width = video.videoWidth * 3;
  canvas.height = video.videoHeight * (3/2);
  whiteBarCanvas.width = canvas.width;
  drawWhiteBar();
});      
      
// Get the ASCII characters to use for the conversion
const asciiChars = ["@", "#", "S", "%", "?", "*", "+", ";", ":", ",", "."];

// Calculate the aspect ratio of the video
let videoAspectRatio = 1;
video.addEventListener("loadedmetadata", () => {
  videoAspectRatio = video.videoWidth / video.videoHeight;
});

      // Add an event listener to the #camera-button element to start and stop the camera stream
      const cameraButton = document.getElementById("camera-button");
      let isCameraOn = false;
      let videoStream = null;
      cameraButton.addEventListener("click", () => {
        if (isCameraOn) {
          isCameraOn = false;
          videoStream.getTracks()[0].stop();
        } else {
          isCameraOn = true;
          navigator.mediaDevices.getUserMedia({ video: true })
            .then((stream) => {
              videoStream = stream;
              video.srcObject = stream;
              video.play();
              convertToAscii();
            })
            .catch((error) => {
              console.error("Error accessing camera:", error);
            });
        }
      });      
      
// Calculate the font size and characters per row for the ASCII art
const fontSize = 3;
const charsPerRow = 500;

// Convert each video frame to ASCII and display it on the page
function convertToAscii() {
  // Draw the current video frame on the canvas
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  // Get the pixel data from the canvas
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

  // Calculate the ASCII art dimensions to match the video aspect ratio
  const asciiWidth = charsPerRow;
  const asciiHeight = Math.floor(canvas.height * videoAspectRatio / fontSize);

  // Create an empty string to store the ASCII art
  let asciiArt = "";

  // Loop through each row of ASCII characters in the image
  for (let y = 0; y < asciiHeight; y++) {
    // Loop through each ASCII character in the row
    for (let x = 0; x < asciiWidth; x++) {
      // Calculate the pixel index in the image data array
      const pixelX = Math.floor(x * videoAspectRatio * fontSize);
      const pixelY = Math.floor(y * fontSize);
      const pixelIndex = (pixelY * canvas.width + pixelX) * 4;

      // Calculate the grayscale value of the pixel
      const grayscaleValue = (imageData[pixelIndex] + imageData[pixelIndex + 1] + imageData[pixelIndex + 2]) / 3;

      // Map the grayscale value to an ASCII character, or use a default character if the index is undefined
      const asciiIndex = Math.floor((grayscaleValue / 255) * asciiChars.length);
      const asciiChar = asciiChars[asciiIndex] || " ";

      // Add the ASCII character to the ASCII art string
      asciiArt += asciiChar;
    }
    asciiArt += "\n"; // Add a newline character at the end of each row
  }

  // Set the font size and display the ASCII art on the page
  document.getElementById("ascii-art").style.fontSize = fontSize + "px";
  document.getElementById("ascii-art").textContent = asciiArt;

  // Call this function again to create a new frame of ASCII art
  requestAnimationFrame(convertToAscii);
}

// Start the video stream and call the conversion function
navigator.mediaDevices
  .getUserMedia({ video: true })
  .then((stream) => {
    video.srcObject = stream;
    video.play();
    convertToAscii();
  })
  .catch((error) => {
    console.error("Error accessing camera:", error);
  });

    </script>

  </body>
</html>
